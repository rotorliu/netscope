// Generated by CoffeeScript 1.12.7
(function() {
  var Renderer,
    hasProp = {}.hasOwnProperty;

  module.exports = Renderer = (function() {
    function Renderer(net, parent1) {
      this.net = net;
      this.parent = parent1;
      this.iconify = false;
      this.layoutDirection = 'tb';
      this.generateGraph();
    }

    Renderer.prototype.setupGraph = function() {
      this.graph = new dagreD3.graphlib.Graph();
      this.graph.setDefaultEdgeLabel((function() {
        return {};
      }));
      return this.graph.setGraph({
        rankdir: this.layoutDirection,
        ranksep: 30,
        nodesep: 10,
        edgesep: 20,
        marginx: 0,
        marginy: 0
      });
    };

    Renderer.prototype.generateGraph = function() {
      var child, i, j, k, l, lastCoalesed, layers, len, len1, len2, len3, len4, m, node, nodes, parent, ref, ref1, ref2, ref3, sink, source, uberParents;
      this.setupGraph();
      nodes = this.net.sortTopologically();
      for (i = 0, len = nodes.length; i < len; i++) {
        node = nodes[i];
        if (node.isInGraph) {
          continue;
        }
        layers = [node].concat(node.coalesce);
        if (layers.length > 1) {
          lastCoalesed = layers[layers.length - 1];
          ref = lastCoalesed.children;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            child = ref[j];
            uberParents = _.clone(child.parents);
            uberParents[uberParents.indexOf(lastCoalesed)] = node;
            child.parents = uberParents;
          }
        }
        this.insertNode(layers);
        ref1 = node.parents;
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          parent = ref1[k];
          this.insertLink(parent, node);
        }
      }
      ref2 = this.graph.sources();
      for (l = 0, len3 = ref2.length; l < len3; l++) {
        source = ref2[l];
        (this.graph.node(source))["class"] = 'node-type-source';
      }
      ref3 = this.graph.sinks();
      for (m = 0, len4 = ref3.length; m < len4; m++) {
        sink = ref3[m];
        (this.graph.node(sink))["class"] = 'node-type-sink';
      }
      return this.render();
    };

    Renderer.prototype.insertNode = function(layers) {
      var baseNode, i, layer, len, nodeClass, nodeDesc, nodeLabel;
      baseNode = layers[0];
      nodeClass = 'node-type-' + baseNode.type.replace(/_/g, '-').toLowerCase();
      nodeLabel = '';
      for (i = 0, len = layers.length; i < len; i++) {
        layer = layers[i];
        layer.isInGraph = true;
        nodeLabel += this.generateLabel(layer);
      }
      nodeDesc = {
        labelType: 'html',
        label: nodeLabel,
        "class": nodeClass,
        layers: layers,
        rx: 5,
        ry: 5
      };
      if (this.iconify) {
        _.extend(nodeDesc, {
          shape: 'circle'
        });
      }
      return this.graph.setNode(baseNode.name, nodeDesc);
    };

    Renderer.prototype.generateLabel = function(layer) {
      if (!this.iconify) {
        return '<div class="node-label">' + layer.name + '</div>';
      } else {
        return '';
      }
    };

    Renderer.prototype.insertLink = function(src, dst) {
      return this.graph.setEdge(src.name, dst.name, {
        arrowhead: 'vee'
      });
    };

    Renderer.prototype.renderKey = function(key) {
      return key.replace(/_/g, ' ');
    };

    Renderer.prototype.renderValue = function(value) {
      if (Array.isArray(value)) {
        return value.join(', ');
      }
      return value;
    };

    Renderer.prototype.renderSection = function(section) {
      var i, isScalarArray, isSection, key, len, ref, s, subSection, val;
      s = '';
      for (key in section) {
        if (!hasProp.call(section, key)) continue;
        val = section[key];
        isScalarArray = Array.isArray(val) && ((val.length === 0) || (typeof val[0] !== 'object'));
        isSection = (typeof val === 'object') && !isScalarArray;
        if (isSection) {
          s += '<div class="node-param-section-title node-param-key">' + this.renderKey(key) + '</div>';
          s += '<div class="node-param-section">';
          ref = [].concat(val);
          for (i = 0, len = ref.length; i < len; i++) {
            subSection = ref[i];
            s += this.renderSection(subSection);
          }
        } else {
          s += '<div class="node-param-row">';
          s += '<span class="node-param-key">' + this.renderKey(key) + ': </span>';
          s += '<span class="node-param-value">' + this.renderValue(val) + '</span>';
        }
        s += '</div>';
      }
      return s;
    };

    Renderer.prototype.tipForNode = function(nodeKey) {
      var i, layer, len, node, ref, s;
      node = this.graph.node(nodeKey);
      s = '';
      ref = node.layers;
      for (i = 0, len = ref.length; i < len; i++) {
        layer = ref[i];
        s += '<div class="node-info-group">';
        s += '<div class="node-info-header">';
        s += '<span class="node-info-title">' + layer.name + '</span>';
        s += ' &middot; ';
        s += '<span class="node-info-type">' + this.renderKey(layer.type) + '</span>';
        if (layer.annotation != null) {
          s += ' &middot; <span class="node-info-annotation">' + layer.annotation + '</span>';
        }
        s += '</div>';
        s += this.renderSection(layer.attribs);
      }
      return s;
    };

    Renderer.prototype.render = function() {
      var bbox, graphRender, margin, svg, svgGroup, that, tipPositions;
      svg = d3.select(this.parent);
      svgGroup = svg.append('g');
      graphRender = new dagreD3.render();
      graphRender(svgGroup, this.graph);
      bbox = svgGroup.node().getBBox();
      svgGroup.attr('transform', 'translate(' + Math.ceil(-bbox.x) + ')');
      margin = 5;
      svg.attr('width', Math.ceil(bbox.width + 2 * margin));
      svg.attr('height', Math.ceil(bbox.height + 2 * margin));
      tipPositions = {
        tb: {
          my: 'left center',
          at: 'right center'
        },
        lr: {
          my: 'top center',
          at: 'bottom center'
        }
      };
      that = this;
      return svgGroup.selectAll("g.node").each(function(nodeKey) {
        var position;
        position = tipPositions[that.layoutDirection];
        position.viewport = $(window);
        return $(this).qtip({
          content: {
            text: that.tipForNode(nodeKey)
          },
          position: position,
          show: {
            delay: 0,
            effect: false
          },
          hide: {
            effect: false
          }
        });
      });
    };

    return Renderer;

  })();

}).call(this);
