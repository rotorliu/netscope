// Generated by CoffeeScript 1.12.7
(function() {
  var Blob, BlobTable, CaffeParser, Layers, LayersGenerator, Network, NodesGenerator, Notify, Parser, Utils, computePrecedingShapes, computeShapes, generateLayers, generateNetwork, setNodeOutputShapesAttribute,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  Parser = require('./parser');

  Layers = require('./layers.coffee');

  Network = require('./../network.coffee');

  Utils = require('./../utils/utils.coffee');

  Notify = require('./../notify.coffee');

  Blob = (function() {
    function Blob(name1) {
      this.name = name1;
      this.addReader = bind(this.addReader, this);
      this.addWriter = bind(this.addWriter, this);
      this.readers = [];
      this.writers = [];
    }

    Blob.prototype.addWriter = function(writerNode) {
      this.writers.push(writerNode);
      if (writerNode.tops == null) {
        writerNode.tops = [];
      }
      return writerNode.tops.push(this);
    };

    Blob.prototype.addReader = function(readerNode) {
      this.readers.push(readerNode);
      if (readerNode.bottoms == null) {
        readerNode.bottoms = [];
      }
      return readerNode.bottoms.push(this);
    };

    Blob.prototype.connectWithNodeAsTop = function(blob, writerNode) {
      return blob.addWriter(writerNode);
    };

    Blob.prototype.connectWithNodeAsBottom = function(blob, readerNode) {
      return blob.addReader(readerNode);
    };

    return Blob;

  })();

  BlobTable = (function() {
    function BlobTable(layers) {
      this.generateBlobsByNames = bind(this.generateBlobsByNames, this);
      this.getBlobByName = bind(this.getBlobByName, this);
      this.fillInternalTable = bind(this.fillInternalTable, this);
      this.table = {};
      this.fillInternalTable(layers);
    }

    BlobTable.prototype.fillInternalTable = function(layers) {
      var i, layer, len, results;
      results = [];
      for (i = 0, len = layers.length; i < len; i++) {
        layer = layers[i];
        this.generateBlobsByNames(layer.top);
        results.push(this.generateBlobsByNames(layer.bottom));
      }
      return results;
    };

    BlobTable.prototype.getBlobByName = function(blobName) {
      return this.table[blobName];
    };

    BlobTable.prototype.generateBlobsByNames = function(blobNames) {
      var blobName, blobNode, i, len, ref, results;
      if (blobNames == null) {
        return;
      }
      ref = Utils.asArray(blobNames);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        blobName = ref[i];
        if (!(blobName in this.table)) {
          blobNode = new Blob(blobName);
          results.push(this.table[blobName] = blobNode);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return BlobTable;

  })();

  NodesGenerator = (function() {
    function NodesGenerator(blobTable1) {
      this.blobTable = blobTable1;
      this.getFirstWriterNode = bind(this.getFirstWriterNode, this);
      this.connectSingleNodeWithBlobs = bind(this.connectSingleNodeWithBlobs, this);
      this.connectNodesWithBlobs = bind(this.connectNodesWithBlobs, this);
      this.connectNonInplaceNodes = bind(this.connectNonInplaceNodes, this);
      this.connectInplaceNodes = bind(this.connectInplaceNodes, this);
      this.connectNodesWithEachOther = bind(this.connectNodesWithEachOther, this);
      this.fillNetwork = bind(this.fillNetwork, this);
    }

    NodesGenerator.prototype.fillNetwork = function(network, layers) {
      this.connectNodesWithBlobs(network, layers);
      this.connectNodesWithEachOther();
      return network;
    };

    NodesGenerator.prototype.connectNodesWithEachOther = function() {
      var blob, inplaceNodes, k, lastInplaceNode, nonInplaceReaders, nonInplaceWriters, ref, results, writerNode;
      ref = this.blobTable.table;
      results = [];
      for (k in ref) {
        if (!hasProp.call(ref, k)) continue;
        blob = ref[k];
        inplaceNodes = _.intersection(blob.writers, blob.readers);
        nonInplaceWriters = _.difference(blob.writers, inplaceNodes);
        nonInplaceReaders = _.difference(blob.readers, inplaceNodes);
        writerNode = this.getFirstWriterNode(blob, nonInplaceWriters);
        if (writerNode != null) {
          lastInplaceNode = this.connectInplaceNodes(writerNode, inplaceNodes);
          results.push(this.connectNonInplaceNodes(lastInplaceNode, nonInplaceReaders));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    NodesGenerator.prototype.connectInplaceNodes = function(parentNode, inplaceNodes) {
      var i, inplaceNode, lastParrentNode, len;
      if (parentNode.coalesce == null) {
        parentNode.coalesce = [];
      }
      lastParrentNode = parentNode;
      for (i = 0, len = inplaceNodes.length; i < len; i++) {
        inplaceNode = inplaceNodes[i];
        inplaceNode.annotation = 'InPlace';
        lastParrentNode.addChild(inplaceNode);
        parentNode.coalesce.push(inplaceNode);
        lastParrentNode = inplaceNode;
      }
      return lastParrentNode;
    };

    NodesGenerator.prototype.connectNonInplaceNodes = function(parentNode, nonInplaceNodes) {
      var i, len, node, results;
      results = [];
      for (i = 0, len = nonInplaceNodes.length; i < len; i++) {
        node = nonInplaceNodes[i];
        results.push(parentNode.addChild(node));
      }
      return results;
    };

    NodesGenerator.prototype.connectNodesWithBlobs = function(network, layers) {
      var i, layer, len, node;
      for (i = 0, len = layers.length; i < len; i++) {
        layer = layers[i];
        node = this.createNode(network, layer);
        this.connectSingleNodeWithBlobs(node, Blob.prototype.connectWithNodeAsTop, layer.top);
        this.connectSingleNodeWithBlobs(node, Blob.prototype.connectWithNodeAsBottom, layer.bottom);
      }
      return network;
    };

    NodesGenerator.prototype.connectSingleNodeWithBlobs = function(node, connectorFunction, blobNames) {
      var blob, blobName, i, len, ref, results;
      if (blobNames == null) {
        return;
      }
      ref = Utils.asArray(blobNames);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        blobName = ref[i];
        blob = this.blobTable.getBlobByName(blobName);
        results.push(connectorFunction(blob, node));
      }
      return results;
    };

    NodesGenerator.prototype.createNode = function(net, layer) {
      var node;
      node = net.createNode(layer.name, layer.type, layer.attribs);
      node.bottoms = [];
      node.tops = [];
      return node;
    };

    NodesGenerator.prototype.getFirstWriterNode = function(blob, nonInplaceWriters) {
      var n;
      if (nonInplaceWriters.length > 1) {
        throw ("Writers number for the '" + blob.name + "' Blob is greater than one.") + ("Non inplace layers with names " + ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = nonInplaceWriters.length; i < len; i++) {
            n = nonInplaceWriters[i];
            results.push(n.name);
          }
          return results;
        })()) + " ") + "write to the same memory, Caffe topology is incorrect.";
      }
      return nonInplaceWriters[0];
    };

    return NodesGenerator;

  })();

  LayersGenerator = (function() {
    function LayersGenerator(descriptors1, header1) {
      this.descriptors = descriptors1;
      this.header = header1;
      this.tryConvertHeaderInputToDataLayer = bind(this.tryConvertHeaderInputToDataLayer, this);
      this.tryConvertInputShapeEntryToDataLayer = bind(this.tryConvertInputShapeEntryToDataLayer, this);
      this.tryExtractDescriptorsFromHeader = bind(this.tryExtractDescriptorsFromHeader, this);
      this.generateRegularLayers = bind(this.generateRegularLayers, this);
      this.generate = bind(this.generate, this);
    }

    LayersGenerator.prototype.generate = function(phase) {
      var layers;
      this.tryExtractDescriptorsFromHeader();
      layers = this.generateRegularLayers(phase);
      return layers;
    };

    LayersGenerator.prototype.generateRegularLayers = function(phase) {
      var entry, headerKeys, i, layer, layerDesc, layers, len, ref;
      if (phase == null) {
        phase = 'train';
      }
      layers = [];
      headerKeys = ['name', 'type', 'top', 'bottom'];
      ref = this.descriptors;
      for (i = 0, len = ref.length; i < len; i++) {
        entry = ref[i];
        layerDesc = entry.layer || entry.layers;
        if (layerDesc != null) {
          layer = {};
          _.extend(layer, _.pick(layerDesc, headerKeys));
          layer.attribs = _.omit(layerDesc, headerKeys);
          layers.push(layer);
        } else {
          console.log('Unidentified entry ignored: ', entry);
        }
      }
      layers = _.filter(layers, function(layer) {
        var layerPhase, ref1;
        layerPhase = (ref1 = layer.attribs.include) != null ? ref1.phase : void 0;
        return !((layerPhase != null) && layerPhase !== phase);
      });
      return layers;
    };

    LayersGenerator.prototype.tryExtractDescriptorsFromHeader = function() {
      var dataLayer;
      if (this.header.layer != null) {
        this.descriptors.unshift(this.header);
        return;
      }
      dataLayer = this.tryConvertHeaderInputToDataLayer();
      if (dataLayer == null) {
        dataLayer = this.tryConvertInputShapeEntryToDataLayer();
      }
      if (dataLayer != null) {
        return this.descriptors.push(dataLayer);
      }
    };

    LayersGenerator.prototype.tryConvertInputShapeEntryToDataLayer = function() {
      var entry, i, inputName, inputShape, len, ref;
      ref = this.descriptors;
      for (i = 0, len = ref.length; i < len; i++) {
        entry = ref[i];
        inputShape = entry.input_shape;
        if (inputShape != null) {
          break;
        }
      }
      if (inputShape != null) {
        inputName = this.header.input || 'data';
        return this.createDataLayerDescriptor(inputName, inputShape.dim);
      }
    };

    LayersGenerator.prototype.tryConvertHeaderInputToDataLayer = function() {
      var inputDim, layerName, ref, ref1;
      layerName = (ref = this.header) != null ? ref.input : void 0;
      inputDim = (ref1 = this.header) != null ? ref1.input_dim : void 0;
      if ((layerName != null) && (inputDim != null)) {
        return this.createDataLayerDescriptor(layerName, inputDim);
      }
    };

    LayersGenerator.prototype.createDataLayerDescriptor = function(name, shape) {
      var layer;
      layer = {
        name: name,
        type: 'Data',
        top: name,
        input_param: {
          shape: shape
        }
      };
      return {
        layer: layer
      };
    };

    return LayersGenerator;

  })();

  generateNetwork = function(layers, header) {
    var blobTable, e, generator, network;
    try {
      network = new Network(header.name);
      blobTable = new BlobTable(layers);
      generator = new NodesGenerator(blobTable);
      return generator.fillNetwork(network, layers);
    } catch (error) {
      e = error;
      return Notify.error("Can't build network graph. " + e);
    }
  };

  generateLayers = function(descriptors, header) {
    var layersGenerator;
    layersGenerator = new LayersGenerator(descriptors, header);
    return layersGenerator.generate();
  };

  setNodeOutputShapesAttribute = function(node) {
    var blob, i, len, ref, ref1, results, shapeText;
    if (!((node != null ? (ref = node.tops) != null ? ref.length : void 0 : void 0) > 0)) {
      return;
    }
    node.attribs.blob_shapes = {};
    ref1 = node.tops;
    results = [];
    for (i = 0, len = ref1.length; i < len; i++) {
      blob = ref1[i];
      shapeText = '[ ' + blob.shape.join(', ') + ' ]';
      results.push(node.attribs.blob_shapes[blob.name] = shapeText);
    }
    return results;
  };

  computePrecedingShapes = function(node) {
    var i, len, parent, ref;
    ref = node.parents;
    for (i = 0, len = ref.length; i < len; i++) {
      parent = ref[i];
      if (!parent.areTopShapesInfered) {
        computePrecedingShapes(parent);
        parent.areTopShapesInfered = true;
      }
    }
    Layers.inferTopShapes(node);
    return setNodeOutputShapesAttribute(node);
  };

  computeShapes = function(net) {
    var e, endNodes, i, len, node, results;
    endNodes = net.findEndNodes();
    try {
      results = [];
      for (i = 0, len = endNodes.length; i < len; i++) {
        node = endNodes[i];
        results.push(computePrecedingShapes(node));
      }
      return results;
    } catch (error) {
      e = error;
      return Notify.warning("Can't infer network data shapes. " + e);
    }
  };

  module.exports = CaffeParser = (function() {
    function CaffeParser() {}

    CaffeParser.parse = function(txt, phase) {
      var descriptors, header, layers, network, ref;
      ref = Parser.parse(txt), header = ref[0], descriptors = ref[1];
      layers = generateLayers(descriptors, header);
      network = generateNetwork(layers, header);
      computeShapes(network);
      return network;
    };

    return CaffeParser;

  })();

}).call(this);
