// Generated by CoffeeScript 1.12.7
(function() {
  var ConvolutionLayerBase, areShapesEqual, extractKernelSizes, extractPaddingSizes, extractStrideSizes, getLayerType, getParameterAsArray, getParameterLength, getValueOrDefault, isDataLayer, isLossLayer, isUniformLayer, layers, shapesToString, utils,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  utils = require('../utils/utils.coffee');

  areShapesEqual = function(x, y) {
    var i, k, ref;
    if (x.length !== y.length) {
      return false;
    }
    for (i = k = 0, ref = x.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      if (x[i] !== y[i]) {
        return false;
      }
    }
    return true;
  };

  getValueOrDefault = function(param, defaultValue) {
    if (param != null) {
      return param;
    } else {
      return defaultValue;
    }
  };

  extractKernelSizes = function(params) {
    return params.kernel_size || [params.kernel_h, params.kernel_w];
  };

  extractPaddingSizes = function(params) {
    if (params.pad != null) {
      return params.pad;
    }
    if ((params.pad_h == null) && (params.pad_w == null)) {
      return 0;
    }
    return [getValueOrDefault(params.pad_h, 0), getValueOrDefault(params.pad_w, 0)];
  };

  extractStrideSizes = function(params) {
    if (params.stride != null) {
      return params.stride;
    }
    if ((params.stride_h == null) && (params.stride_w == null)) {
      return 1;
    }
    return [getValueOrDefault(params.stride_h, 1), getValueOrDefault(params.stride_w, 1)];
  };

  getParameterAsArray = function(parameter, requiredLength, name) {
    var i;
    if (utils.typeIsArray(parameter)) {
      if (parameter.length !== requiredLength) {
        throw ("Dimensions of the '" + name + "' parameter ") + ("must be equal to " + requiredLength + ".");
      }
      return parameter;
    }
    return (function() {
      var k, ref, results;
      results = [];
      for (i = k = 0, ref = requiredLength; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        results.push(parameter);
      }
      return results;
    })();
  };

  getParameterLength = function(parameter) {
    if (parameter != null) {
      if (utils.typeIsArray(parameter)) {
        return parameter.length;
      } else {
        return 1;
      }
    } else {
      return 0;
    }
  };

  shapesToString = function(inputShapes) {
    var k, len, shape, text;
    text = '[';
    for (k = 0, len = inputShapes.length; k < len; k++) {
      shape = inputShapes[k];
      text += " [ " + shape + " ]";
    }
    text += ' ]';
    return text;
  };

  layers = {};

  layers.Uniform = this.UniformLayer = (function() {
    function UniformLayer() {}

    UniformLayer.prototype.inferShapes = function(bottoms, tops) {
      var i, k, ref, results;
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      results = [];
      for (i = k = 0, ref = tops.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        results.push(tops[i].shape = bottoms[i].shape.slice(0));
      }
      return results;
    };

    return UniformLayer;

  })();

  layers.Loss = this.LossLayer = (function() {
    function LossLayer() {}

    LossLayer.prototype.inferShapes = function(bottoms, tops) {
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      return tops[0].shape = [1];
    };

    return LossLayer;

  })();

  layers.Data = this.DataLayer = (function() {
    function DataLayer(attribs) {
      this.tryExtractShapeFromMemoryDataLayer = bind(this.tryExtractShapeFromMemoryDataLayer, this);
      this.tryExtractShapeFromTransformParam = bind(this.tryExtractShapeFromTransformParam, this);
      this.tryExtractShapes = bind(this.tryExtractShapes, this);
      this.checkParameters = bind(this.checkParameters, this);
      this.inferShapes = bind(this.inferShapes, this);
      this.defaultBatchSize = 1;
      this.defaultChannels = 3;
      this.outputShape = this.tryExtractShapes(attribs);
    }

    DataLayer.prototype.inferShapes = function(bottoms, tops) {
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      this.checkParameters(bottoms, tops);
      tops[0].shape = this.outputShape.slice(0);
      if (tops[1]) {
        return tops[1].shape = this.outputShape.slice(0, 1);
      }
    };

    DataLayer.prototype.checkParameters = function(bottoms, tops) {
      var ref;
      if (this.outputShape == null) {
        throw "Can't extract data shape from Data layer";
      }
      if ((bottoms != null ? bottoms.length : void 0) > 0) {
        throw "Data layer doesn't expect any input.";
      }
      if ((ref = tops != null ? tops.length : void 0) !== 1 && ref !== 2) {
        throw 'Outputs number of Data layer must be equal to one or two.';
      }
    };

    DataLayer.prototype.tryExtractShapes = function(attribs) {
      var ref, ref1, ref2, shape;
      shape = attribs != null ? (ref = attribs.input_param) != null ? (ref1 = ref.shape) != null ? ref1.dim : void 0 : void 0 : void 0;
      if (shape == null) {
        shape = attribs != null ? (ref2 = attribs.input_param) != null ? ref2.shape : void 0 : void 0;
      }
      if (shape == null) {
        shape = attribs != null ? attribs.shape : void 0;
      }
      if (shape == null) {
        shape = this.tryExtractShapeFromTransformParam(attribs);
      }
      if (shape == null) {
        shape = this.tryExtractShapeFromMemoryDataLayer(attribs);
      }
      return shape;
    };

    DataLayer.prototype.tryExtractShapeFromTransformParam = function(attribs) {
      var channels, cropSize, ref;
      cropSize = (ref = attribs.transform_param) != null ? ref.crop_size : void 0;
      if (cropSize != null) {
        channels = this.defaultChannels;
        if (attribs.transform_param.force_gray) {
          channels = 1;
        }
        return [this.defaultBatchSize, channels, cropSize, cropSize];
      }
    };

    DataLayer.prototype.tryExtractShapeFromMemoryDataLayer = function(attribs) {
      var batch_size, channels, height, param, width;
      param = attribs != null ? attribs.memory_data_param : void 0;
      batch_size = param.batch_size || this.defaultBatchSize;
      channels = param.channels || this.defaultChannels;
      height = param.height;
      width = param.width;
      if ((height != null) && (width != null)) {
        return [batch_size, channels, height, width];
      }
    };

    return DataLayer;

  })();

  ConvolutionLayerBase = (function() {
    function ConvolutionLayerBase(name1, attribs) {
      var params;
      this.name = name1;
      this.checkParameters = bind(this.checkParameters, this);
      this.inferShapesForOneBlobInternal = bind(this.inferShapesForOneBlobInternal, this);
      this.inferShapesForOneBlob = bind(this.inferShapesForOneBlob, this);
      this.inferShapes = bind(this.inferShapes, this);
      params = attribs != null ? attribs.convolution_param : void 0;
      if (params == null) {
        throw this.name + " layer must have convolution_param.";
      }
      this.filters = params.num_output;
      this.padding = extractPaddingSizes(params);
      this.stride = extractStrideSizes(params);
      this.kernel = extractKernelSizes(params);
      this.dilation = getValueOrDefault(params.dilation, 1);
      this.axis = getValueOrDefault(params.axis, 1);
    }

    ConvolutionLayerBase.prototype.inferShapes = function(bottoms, tops) {
      var i, k, ref, results;
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      this.checkParameters(bottoms, tops);
      results = [];
      for (i = k = 0, ref = tops.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.inferShapesForOneBlob(bottoms[i], tops[i]));
      }
      return results;
    };

    ConvolutionLayerBase.prototype.inferShapesForOneBlob = function(bottom, top) {
      var dilation, inputShape, kernel, outputShape, padding, stride, sucDimLength, succeedingDimensions;
      inputShape = bottom.shape;
      outputShape = inputShape.slice(0);
      succeedingDimensions = inputShape.slice(this.axis + 1);
      sucDimLength = succeedingDimensions.length;
      padding = getParameterAsArray(this.padding, sucDimLength, 'padding');
      kernel = getParameterAsArray(this.kernel, sucDimLength, 'kernel');
      stride = getParameterAsArray(this.stride, sucDimLength, 'stride');
      dilation = getParameterAsArray(this.dilation, sucDimLength, 'dilation');
      this.inferShapesForOneBlobInternal(inputShape, outputShape, padding, kernel, stride, dilation);
      return top.shape = outputShape;
    };

    ConvolutionLayerBase.prototype.inferShapesForOneBlobInternal = function(input, output, padding, kernel, stride, dilation) {
      return void 0;
    };

    ConvolutionLayerBase.prototype.checkParameters = function(bottoms, tops) {
      if (this.filters == null) {
        throw this.name + " layer must have num_output parameter.";
      }
      if ((this.kernel == null) && ((this.kernel[0] == null) || (this.kernel[1] == null))) {
        console.log(this.kernel);
        throw this.name + " kernel sizes must be set.";
      }
      if (bottoms == null) {
        throw this.name + " layer received undefined bottom blobs.";
      }
      if (bottoms.length !== tops.length) {
        throw (this.name + " layer can process number of top blobs which is equal to ") + ("the number of bottom blobs, but received " + tops.length + " top blobs and ") + (bottoms.length + " bottom blobs.");
      }
    };

    return ConvolutionLayerBase;

  })();

  layers.Convolution = this.ConvolutionLayer = (function(superClass) {
    extend(ConvolutionLayer, superClass);

    function ConvolutionLayer(attribs) {
      this.inferShapesForOneBlobInternal = bind(this.inferShapesForOneBlobInternal, this);
      ConvolutionLayer.__super__.constructor.call(this, 'Convolution', attribs);
    }

    ConvolutionLayer.prototype.inferShapesForOneBlobInternal = function(input, output, padding, kernel, stride, dilation) {
      var i, ii, k, kernelExtent, outDim, ref, ref1, results;
      output[this.axis] = this.filters;
      results = [];
      for (i = k = ref = this.axis + 1, ref1 = input.length; ref <= ref1 ? k < ref1 : k > ref1; i = ref <= ref1 ? ++k : --k) {
        ii = i - this.axis - 1;
        kernelExtent = dilation[ii] * (kernel[ii] - 1) + 1;
        outDim = (input[i] + 2 * padding[ii] - kernelExtent) / stride[ii] + 1;
        results.push(output[i] = Math.floor(outDim));
      }
      return results;
    };

    return ConvolutionLayer;

  })(ConvolutionLayerBase);

  layers.Deconvolution = this.DeconvolutionLayer = (function(superClass) {
    extend(DeconvolutionLayer, superClass);

    function DeconvolutionLayer(attribs) {
      this.inferShapesForOneBlobInternal = bind(this.inferShapesForOneBlobInternal, this);
      DeconvolutionLayer.__super__.constructor.call(this, 'Deconvolution', attribs);
    }

    DeconvolutionLayer.prototype.inferShapesForOneBlobInternal = function(input, output, padding, kernel, stride, dilation) {
      var i, ii, k, kernelExtent, outDim, ref, ref1, results;
      output[this.axis] = this.filters;
      results = [];
      for (i = k = ref = this.axis + 1, ref1 = input.length; ref <= ref1 ? k < ref1 : k > ref1; i = ref <= ref1 ? ++k : --k) {
        ii = i - this.axis - 1;
        kernelExtent = dilation[ii] * (kernel[ii] - 1) + 1;
        outDim = stride[ii] * (input[i] - 1) + kernelExtent - 2 * padding[ii];
        results.push(output[i] = Math.floor(outDim));
      }
      return results;
    };

    return DeconvolutionLayer;

  })(ConvolutionLayerBase);

  layers.Pooling = this.PoolingLayer = (function() {
    function PoolingLayer(attribs) {
      this.getKernelSizes = bind(this.getKernelSizes, this);
      this.checkParameters = bind(this.checkParameters, this);
      this.inferShapes = bind(this.inferShapes, this);
      var params;
      this.spatialDimSize = 2;
      params = attribs != null ? attribs.pooling_param : void 0;
      if (params == null) {
        throw 'Pooling layer must have pooling_param.';
      }
      this.padding = extractPaddingSizes(params);
      this.stride = extractStrideSizes(params);
      this.kernel = extractKernelSizes(params);
      this.isGlobalPooling = getValueOrDefault(params.global_pooling, false);
    }

    PoolingLayer.prototype.inferShapes = function(bottoms, tops) {
      var i, ii, inputShape, k, kernel, outDim, outDimRounded, outputShape, padding, ref, stride;
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      this.checkParameters(bottoms, tops);
      inputShape = bottoms[0].shape;
      outputShape = inputShape.slice(0);
      padding = getParameterAsArray(this.padding, this.spatialDimSize, 'padding');
      stride = getParameterAsArray(this.stride, this.spatialDimSize, 'stride');
      kernel = this.getKernelSizes(inputShape);
      for (i = k = 0, ref = this.spatialDimSize; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        ii = inputShape.length - this.spatialDimSize + i;
        outDim = (inputShape[ii] + 2 * padding[i] - kernel[i]) / stride[i];
        outDimRounded = (Math.floor(Math.ceil(outDim))) + 1;
        if ((outDimRounded - 1) * stride[i] >= inputShape[ii] + padding[i]) {
          outDimRounded--;
        }
        outputShape[ii] = outDimRounded;
      }
      tops[0].shape = outputShape;
      if (tops[1]) {
        return tops[1].shape = outputShape.slice(0);
      }
    };

    PoolingLayer.prototype.checkParameters = function(bottoms, tops) {
      var ref;
      if ((this.kernel == null) && ((this.kernel[0] == null) || (this.kernel[1] == null))) {
        throw 'Pooling layer must have kernel_size parameter.';
      }
      if (bottoms == null) {
        throw 'Pooling layer received undefined bottom blobs.';
      }
      if (bottoms.length !== 1) {
        throw "Pooling layer can process exactly one input, " + ("but received " + bottoms.length + " input shapes.");
      }
      if ((ref = tops.length) !== 1 && ref !== 2) {
        throw "Pooling layer produces single output shape or two equal " + "shapes if the second top shape is specified.";
      }
    };

    PoolingLayer.prototype.getKernelSizes = function(inputShape) {
      var kernel;
      if (this.isGlobalPooling) {
        kernel = inputShape.slice(-this.spatialDimSize);
      } else {
        kernel = getParameterAsArray(this.kernel, this.spatialDimSize, 'kernel');
      }
      return kernel;
    };

    return PoolingLayer;

  })();

  layers.InnerProduct = this.InnerProductLayer = (function() {
    function InnerProductLayer(attribs) {
      this.checkParameters = bind(this.checkParameters, this);
      this.inferShapes = bind(this.inferShapes, this);
      var params;
      params = attribs != null ? attribs.inner_product_param : void 0;
      if (params == null) {
        throw 'InnerProduct layer must have inner_product_param.';
      }
      this.numOutput = params.num_output;
      this.axis = getValueOrDefault(params.axis, 1);
    }

    InnerProductLayer.prototype.inferShapes = function(bottoms, tops) {
      var inputShape, outputShape;
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      this.checkParameters(bottoms, tops);
      inputShape = bottoms[0].shape;
      outputShape = inputShape.slice(0, this.axis);
      outputShape[this.axis] = this.numOutput;
      return tops[0].shape = outputShape;
    };

    InnerProductLayer.prototype.checkParameters = function(bottoms, tops) {
      if (this.numOutput == null) {
        throw 'InnerProduct layer must have num_output parameter.';
      }
      if (bottoms == null) {
        throw 'InnerProduct layer received undefined bottom blobs.';
      }
      if (bottoms.length !== 1 || tops.length !== 1) {
        throw "InnerProduct layer can accept and produce exactly one blob, but " + ("received " + bottoms.length + " bottoms blobs and " + tops.length + " top blobs.");
      }
    };

    return InnerProductLayer;

  })();

  layers.Concat = this.ConcatLayer = (function() {
    function ConcatLayer(attribs) {
      this.checkInputShapeAxes = bind(this.checkInputShapeAxes, this);
      this.checkParameters = bind(this.checkParameters, this);
      this.inferShapes = bind(this.inferShapes, this);
      var axis, params;
      params = attribs != null ? attribs.concat_param : void 0;
      axis = params != null ? params.concat_dim : void 0;
      if (axis == null) {
        axis = params != null ? params.axis : void 0;
      }
      this.axis = getValueOrDefault(axis, 1);
    }

    ConcatLayer.prototype.inferShapes = function(bottoms, tops) {
      var bottom, firstInputShape, k, len, outputShape;
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      this.checkParameters(bottoms, tops);
      firstInputShape = bottoms[0].shape;
      outputShape = firstInputShape.slice(0);
      outputShape[this.axis] = 0;
      for (k = 0, len = bottoms.length; k < len; k++) {
        bottom = bottoms[k];
        outputShape[this.axis] += bottom.shape[this.axis];
      }
      return tops[0].shape = outputShape;
    };

    ConcatLayer.prototype.checkParameters = function(bottoms, tops) {
      var bottom, firstShape, inputShapes, k, len, results, shape;
      if ((bottoms != null ? bottoms[0] : void 0) == null) {
        throw 'Concat layer must have at least one bottom blob.';
      }
      firstShape = bottoms[0].shape;
      inputShapes = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = bottoms.length; k < len; k++) {
          bottom = bottoms[k];
          results.push(bottom.shape);
        }
        return results;
      })();
      results = [];
      for (k = 0, len = inputShapes.length; k < len; k++) {
        shape = inputShapes[k];
        if (!this.checkInputShapeAxes(firstShape, shape)) {
          throw "Concat layer received incorrect input shapes: " + ((shapesToString(inputShapes)) + ". ") + "All axes except axis along which concatenation " + "is performing must have the same sizes.";
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    ConcatLayer.prototype.checkInputShapeAxes = function(firstShape, shape) {
      var i, k, ref;
      if (firstShape.length !== shape.length) {
        return false;
      }
      for (i = k = 0, ref = shape.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        if (i !== this.axis && firstShape[i] !== shape[i]) {
          return false;
        }
      }
      return true;
    };

    return ConcatLayer;

  })();

  layers.Slice = this.SliceLayer = (function() {
    function SliceLayer(attribs) {
      this.checkParameters = bind(this.checkParameters, this);
      this.inferShapes = bind(this.inferShapes, this);
      var params;
      params = attribs != null ? attribs.slice_param : void 0;
      this.slicePoint = params != null ? params.slice_point : void 0;
      this.axis = getValueOrDefault(params.axis, 1);
    }

    SliceLayer.prototype.inferShapes = function(bottoms, tops) {
      var firstInputShape, i, k, ref;
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      this.slicePoint = getParameterAsArray(this.slicePoint, tops.length - 1, 'slice_point');
      this.checkParameters(bottoms, tops);
      firstInputShape = bottoms[0].shape;
      for (i = k = 0, ref = tops.length - 1; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        tops[i].shape = firstInputShape.slice(0);
        tops[i].shape[this.axis] = this.slicePoint[i];
      }
      tops[tops.length - 1].shape = firstInputShape.slice(0);
      return tops[tops.length - 1].shape[this.axis] = firstInputShape[this.axis] - this.slicePoint[this.slicePoint.length - 1];
    };

    SliceLayer.prototype.checkParameters = function(bottoms, tops) {
      if ((bottoms != null ? bottoms[0] : void 0) == null) {
        throw 'Slice layer must have at least one bottom blob.';
      }
      if ((tops != null ? tops[1] : void 0) == null) {
        throw 'Slice layer must have at least two top blob.';
      }
    };

    return SliceLayer;

  })();

  layers.Permute = this.PermuteLayer = (function() {
    function PermuteLayer(attribs) {
      this.inferShapes = bind(this.inferShapes, this);
      var params;
      params = attribs != null ? attribs.permute_param : void 0;
      this.order = params != null ? params.order : void 0;
    }

    PermuteLayer.prototype.inferShapes = function(bottoms, tops) {
      var bottom, firstInputShape, i, k, ref, results, top;
      this.order = getParameterAsArray(this.order, bottoms[0].shape.length, 'order');
      firstInputShape = bottoms[0].shape;
      top = tops[0];
      bottom = bottoms[0];
      top.shape = firstInputShape.slice(0);
      results = [];
      for (i = k = 0, ref = this.order.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        results.push(top.shape[i] = bottom.shape[this.order[i]]);
      }
      return results;
    };

    return PermuteLayer;

  })();

  layers.Flatten = this.FlattenLayer = (function() {
    function FlattenLayer(attribs) {
      this.inferShapes = bind(this.inferShapes, this);
      var params;
      params = attribs != null ? attribs.flatten_param : void 0;
      this.axis = getValueOrDefault(params.axis, 1);
    }

    FlattenLayer.prototype.inferShapes = function(bottoms, tops) {
      var i, k, outputShape, ref, ref1, results, top;
      outputShape = bottoms[0].shape;
      top = tops[0];
      top.shape = outputShape.slice(0, this.axis + 1);
      results = [];
      for (i = k = ref = this.axis + 1, ref1 = outputShape.length; ref <= ref1 ? k < ref1 : k > ref1; i = ref <= ref1 ? ++k : --k) {
        results.push(top.shape[this.axis] *= outputShape[i]);
      }
      return results;
    };

    return FlattenLayer;

  })();

  layers.PriorBox = this.PriorBoxLayer = (function() {
    function PriorBoxLayer(attribs) {
      this.inferShapes = bind(this.inferShapes, this);
      var params;
      params = attribs != null ? attribs.prior_box_param : void 0;
      this.min_size = params != null ? params.min_size : void 0;
      this.max_size = params != null ? params.max_size : void 0;
      this.aspect_ratio = params != null ? params.aspect_ratio : void 0;
      this.flip = params != null ? params.flip : void 0;
    }

    PriorBoxLayer.prototype.inferShapes = function(bottoms, tops) {
      var already_exist, ar, aspect_ratio_length, aspect_ratio_param_length, aspect_ratios, height, i, j, k, l, len, len1, len2, m, max_size_length, min_size_length, num_priors, outputShape, ref, ref1, ref2, width;
      min_size_length = getParameterLength(this.min_size);
      max_size_length = getParameterLength(this.max_size);
      aspect_ratio_param_length = getParameterLength(this.aspect_ratio);
      aspect_ratios = [1.0];
      if (aspect_ratio_param_length === 1) {
        ar = this.aspect_ratio;
        already_exist = false;
        ref = aspect_ratios.length;
        for (k = 0, len = ref.length; k < len; k++) {
          j = ref[k];
          if (Math.abs(ar - aspect_ratios[j]) < 1e-6) {
            already_exist = true;
            break;
          }
        }
        if (already_exist !== true) {
          aspect_ratios.push(ar);
          if (this.flip) {
            aspect_ratios.push(1.0 / ar);
          }
        }
      } else {
        ref1 = this.aspect_ratio;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          i = ref1[l];
          ar = i;
          already_exist = false;
          ref2 = aspect_ratios.length;
          for (m = 0, len2 = ref2.length; m < len2; m++) {
            j = ref2[m];
            if (Math.abs(ar - aspect_ratios[j]) < 1e-6) {
              already_exist = true;
              break;
            }
          }
          if (already_exist !== true) {
            aspect_ratios.push(ar);
            if (this.flip) {
              aspect_ratios.push(1.0 / ar);
            }
          }
        }
      }
      aspect_ratio_length = aspect_ratios.length;
      outputShape = bottoms[0].shape;
      height = bottoms[0].shape[2];
      width = bottoms[0].shape[3];
      num_priors = aspect_ratio_length * min_size_length + max_size_length;
      tops[0].shape = outputShape.slice(0, 3);
      tops[0].shape[0] = 1;
      tops[0].shape[1] = 2;
      return tops[0].shape[2] = height * width * num_priors * 4;
    };

    return PriorBoxLayer;

  })();

  layers.Reshape = this.ReshapeLayer = (function() {
    function ReshapeLayer(attribs) {
      this.inferShapes = bind(this.inferShapes, this);
      var params;
      params = attribs != null ? attribs.reshape_param : void 0;
      this.shape = params != null ? params.shape : void 0;
    }

    ReshapeLayer.prototype.inferShapes = function(bottoms, tops) {
      var dim, dim_length, i, k, l, m, other_sum, outputShape, ref, ref1, ref2, results, sum;
      dim_length = getParameterLength(this.shape.dim);
      dim = getParameterAsArray(this.shape.dim, dim_length, 'dim');
      outputShape = bottoms[0].shape;
      sum = 1;
      for (i = k = 0, ref = bottoms[0].shape.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        sum *= bottoms[0].shape[i];
      }
      tops[0].shape = outputShape.slice(0, dim_length);
      other_sum = 1;
      for (i = l = 0, ref1 = dim_length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
        if (dim[i] !== 0 && dim[i] !== -1) {
          tops[0].shape[i] = dim[i];
        }
        if (dim[i] !== -1) {
          other_sum *= tops[0].shape[i];
        }
      }
      results = [];
      for (i = m = 0, ref2 = dim_length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
        if (dim[i] === -1) {
          results.push(tops[0].shape[i] = sum / other_sum);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return ReshapeLayer;

  })();

  layers.Tiling = this.TilingLayer = (function() {
    function TilingLayer(attribs) {
      this.checkParameters = bind(this.checkParameters, this);
      this.inferShapes = bind(this.inferShapes, this);
      var params;
      params = attribs != null ? attribs.tiling_param : void 0;
      this.tile_dim = params != null ? params.tile_dim : void 0;
    }

    TilingLayer.prototype.inferShapes = function(bottoms, tops) {
      var channels, height, outputShape, width;
      this.checkParameters(bottoms, tops);
      outputShape = bottoms[0].shape;
      channels = bottoms[0].shape[1];
      height = bottoms[0].shape[2];
      width = bottoms[0].shape[3];
      tops[0].shape = outputShape;
      tops[0].shape[1] = channels / (this.tile_dim * this.tile_dim);
      tops[0].shape[2] = height * this.tile_dim;
      return tops[0].shape[3] = width * this.tile_dim;
    };

    TilingLayer.prototype.checkParameters = function(bottoms, tops) {
      if (this.tile_dim == null) {
        throw 'tile_dim must be specified.';
      }
      if (!(this.tile_dim > 0)) {
        throw 'tile_dim must be positive.';
      }
      if (bottoms[0].shape[1] % (this.tile_dim * this.tile_dim) !== 0) {
        throw 'The number of input channels for tiling layer must be multiples of the tile_dim.';
      }
    };

    return TilingLayer;

  })();

  layers.Normalize = this.NormalizeLayer = (function() {
    function NormalizeLayer(attribs) {
      this.inferShapes = bind(this.inferShapes, this);
      var params;
      params = attribs != null ? attribs.norm_param : void 0;
      this.across_spatial = params != null ? params.across_spatial : void 0;
      this.channel_shared = params != null ? params.channel_shared : void 0;
    }

    NormalizeLayer.prototype.inferShapes = function(bottoms, tops) {
      var outputShape;
      outputShape = bottoms[0].shape;
      return tops[0].shape = outputShape;
    };

    return NormalizeLayer;

  })();

  layers.Eltwise = this.EltwiseLayer = (function() {
    function EltwiseLayer() {
      this.checkParameters = bind(this.checkParameters, this);
      this.inferShapes = bind(this.inferShapes, this);
    }

    EltwiseLayer.prototype.inferShapes = function(bottoms, tops) {
      var firstInputShape;
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      this.checkParameters(bottoms, tops);
      firstInputShape = bottoms[0].shape;
      return tops[0].shape = firstInputShape.slice(0);
    };

    EltwiseLayer.prototype.checkParameters = function(bottoms, tops) {
      var bottom, firstShape, inputShapes, k, len, results, shape;
      if ((bottoms != null ? bottoms[0] : void 0) == null) {
        throw 'Eltwise layer must have at least one input.';
      }
      inputShapes = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = bottoms.length; k < len; k++) {
          bottom = bottoms[k];
          results.push(bottom.shape);
        }
        return results;
      })();
      firstShape = inputShapes[0];
      results = [];
      for (k = 0, len = inputShapes.length; k < len; k++) {
        shape = inputShapes[k];
        if (!areShapesEqual(firstShape, shape)) {
          throw "Eltwise layer received incorrect input shapes: " + ((shapesToString(inputShapes)) + ". ") + "All axes must have the same sizes.";
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return EltwiseLayer;

  })();

  layers.Axpy = this.AxpyLayer = (function() {
    function AxpyLayer() {
      this.checkParameters = bind(this.checkParameters, this);
      this.inferShapes = bind(this.inferShapes, this);
    }

    AxpyLayer.prototype.inferShapes = function(bottoms, tops) {
      var firstInputShape;
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      this.checkParameters(bottoms, tops);
      firstInputShape = bottoms[1].shape;
      return tops[0].shape = firstInputShape.slice(0);
    };

    AxpyLayer.prototype.checkParameters = function(bottoms, tops) {
      var bottom, firstShape, inputShapes;
      if ((bottoms != null ? bottoms.length : void 0) !== 3) {
        throw 'Axpy layer must have three inputs.';
      }
      inputShapes = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = bottoms.length; k < len; k++) {
          bottom = bottoms[k];
          results.push(bottom.shape);
        }
        return results;
      })();
      firstShape = inputShapes[0];
      if (inputShapes[0][0] !== inputShapes[1][0]) {
        throw "InputShapes 0 and 1 at 0 axe must have the same sizes.";
      }
      if (inputShapes[0][1] !== inputShapes[1][1]) {
        throw "InputShapes 0 and 1 at 1 axe must have the same sizes.";
      }
      if (inputShapes[0].length === 4) {
        if (inputShapes[0][2] !== 1 || inputShapes[0][3] !== 1) {
          throw "InputShapes 0 at 2、3 axe must be 1.";
        }
      }
      if (!areShapesEqual(inputShapes[1], inputShapes[2])) {
        throw "Axpy layer received incorrect input shapes: " + ((shapesToString(inputShapes)) + ". ") + "InputShapes 1 and 2 at all axes must have the same sizes.";
      }
    };

    return AxpyLayer;

  })();

  layers.Crop = this.CropLayer = (function() {
    function CropLayer(attribs) {
      this.checkParameters = bind(this.checkParameters, this);
      this.inferShapes = bind(this.inferShapes, this);
      var params;
      params = attribs.crop_param;
      this.axis = getValueOrDefault(params != null ? params.axis : void 0, 0);
    }

    CropLayer.prototype.inferShapes = function(bottoms, tops) {
      var i, k, outputShape, ref, ref1;
      if ((tops != null ? tops[0] : void 0) == null) {
        return;
      }
      this.checkParameters(bottoms, tops);
      outputShape = bottoms[0].shape.slice(0);
      for (i = k = ref = this.axis, ref1 = outputShape.length; ref <= ref1 ? k < ref1 : k > ref1; i = ref <= ref1 ? ++k : --k) {
        outputShape[i] = bottoms[1].shape[i];
      }
      return tops[0].shape = outputShape;
    };

    CropLayer.prototype.checkParameters = function(bottoms, tops) {
      if ((bottoms != null ? bottoms.length : void 0) !== 2) {
        throw 'Crop layer must have exactly two bottom blobs.';
      }
    };

    return CropLayer;

  })();

  isLossLayer = function(layerType) {
    return /loss/i.test(layerType);
  };

  isDataLayer = function(layerType) {
    return (/input/i.test(layerType)) || (/data/i.test(layerType));
  };

  isUniformLayer = function(lt) {
    return (/relu/i.test(lt)) || (/prelu/i.test(lt)) || (/elu/i.test(lt)) || (/sigmoid/i.test(lt)) || (/tanh/i.test(lt)) || (/abs/i.test(lt)) || (/power/i.test(lt)) || (/exp/i.test(lt)) || (/log/i.test(lt)) || (/bnll/i.test(lt)) || (/threshold/i.test(lt)) || (/bias/i.test(lt)) || (/scale/i.test(lt)) || (/lrn/i.test(lt)) || (/dropout/i.test(lt)) || (/batchnorm/i.test(lt)) || (/mvn/i.test(lt)) || (/softmax/i.test(lt));
  };

  getLayerType = function(layerTypeName) {
    var layerType, layerTypeNameTitle;
    if (isUniformLayer(layerTypeName)) {
      return layers.Uniform;
    }
    if (isDataLayer(layerTypeName)) {
      return layers.Data;
    }
    if (isLossLayer(layerTypeName)) {
      return layers.Loss;
    }
    layerType = layers[layerTypeName];
    if (layerType == null) {
      layerTypeNameTitle = utils.toTitleCase(layerTypeName);
      layerType = layers[layerTypeNameTitle];
    }
    if (layerType == null) {
      throw "Unsupported layer type: '" + layerTypeName + "'.";
    }
    return layerType;
  };

  exports.inferTopShapes = function(node) {
    var LayerType, e, layer, top;
    try {
      LayerType = getLayerType(node.type);
      layer = new LayerType(node.attribs);
      layer.inferShapes(node.bottoms, node.tops);
      return (function() {
        var k, len, ref, results;
        ref = node.tops;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          top = ref[k];
          results.push(top.shape);
        }
        return results;
      })();
    } catch (error) {
      e = error;
      throw ("Can't infer output shape of the '" + node.name + "' ") + ("layer of type '" + node.type + "'. ") + e;
    }
  };

}).call(this);
