// Generated by CoffeeScript 1.12.7
(function() {
  var Network, Node,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Node = (function() {
    function Node(name, type1, attribs1) {
      this.name = name;
      this.type = type1;
      this.attribs = attribs1 != null ? attribs1 : {};
      this.detachChildren = bind(this.detachChildren, this);
      this.detachChild = bind(this.detachChild, this);
      this.addParents = bind(this.addParents, this);
      this.addParent = bind(this.addParent, this);
      this.addChildren = bind(this.addChildren, this);
      this.addChild = bind(this.addChild, this);
      this.hasChildren = bind(this.hasChildren, this);
      this.parents = [];
      this.children = [];
      this.coalesce = [];
    }

    Node.prototype.hasChildren = function() {
      return this.children.length > 0;
    };

    Node.prototype.addChild = function(child) {
      if (indexOf.call(this.children, child) < 0) {
        this.children.push(child);
        if (indexOf.call(child.parents, this) < 0) {
          return child.parents.push(this);
        }
      }
    };

    Node.prototype.addChildren = function(children) {
      return _.forEach(children, (function(_this) {
        return function(c) {
          return _this.addChild(c);
        };
      })(this));
    };

    Node.prototype.addParent = function(parent) {
      return parent.addChild(this);
    };

    Node.prototype.addParents = function(parents) {
      return _.forEach(parents, (function(_this) {
        return function(p) {
          return _this.addParent(p);
        };
      })(this));
    };

    Node.prototype.detachChild = function(child) {
      _.pull(this.children, child);
      return _.pull(child.parents, this);
    };

    Node.prototype.detachChildren = function() {
      var children;
      children = _.clone(this.children);
      _.forEach(children, (function(_this) {
        return function(c) {
          return _this.detachChild(c);
        };
      })(this));
      return children;
    };

    return Node;

  })();

  module.exports = Network = (function() {
    function Network(name) {
      this.name = name != null ? name : 'Untitled Network';
      this.sortTopologically = bind(this.sortTopologically, this);
      this.findEndNodes = bind(this.findEndNodes, this);
      this.nodes = [];
    }

    Network.prototype.createNode = function(label, type, attribs) {
      var node;
      node = new Node(label, type, attribs);
      this.nodes.push(node);
      return node;
    };

    Network.prototype.findEndNodes = function() {
      var i, len, ref, results, x;
      ref = this.nodes;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        x = ref[i];
        if (!x.hasChildren()) {
          results.push(x);
        }
      }
      return results;
    };

    Network.prototype.sortTopologically = function() {
      var i, j, len, len1, node, sortedNodes, unsortedNodes, visit;
      sortedNodes = [];
      unsortedNodes = _.clone(this.nodes);
      for (i = 0, len = unsortedNodes.length; i < len; i++) {
        node = unsortedNodes[i];
        node.sort_ = {
          temp: false,
          perm: false
        };
      }
      visit = function(node) {
        var child, j, len1, ref;
        if (node.sort_.temp === true) {
          throw 'Graph is not a DAG. Complicit node: ' + node.name;
        }
        if (node.sort_.perm) {
          return;
        }
        node.sort_.temp = true;
        ref = node.children;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          child = ref[j];
          visit(child);
        }
        node.sort_.perm = true;
        node.sort_.temp = false;
        return sortedNodes.unshift(node);
      };
      while (unsortedNodes.length !== 0) {
        visit(unsortedNodes.pop());
      }
      for (j = 0, len1 = sortedNodes.length; j < len1; j++) {
        node = sortedNodes[j];
        delete node.sort_;
      }
      return sortedNodes;
    };

    return Network;

  })();

}).call(this);
